from math import sqrt
from numpy import concatenate
from matplotlib import pyplot
import numpy as np
from pandas import read_csv
from pandas import DataFrame
from pandas import concat
from sklearn.preprocessing import MinMaxScaler
from sklearn.preprocessing import LabelEncoder
from sklearn.metrics import mean_squared_error
from keras.models import Sequential
from keras.layers import Dense
from keras.layers import LSTM
from keras.layers.core import RepeatVector
from keras.models import model_from_yaml

#這是攤開版本
def data_to_reconstruction_problem(data,timestep):
    df= DataFrame(data)
    list_concat = list()
    for i in range(timestep-1, -1, -1):
        tempdf = df.shift(i)
        list_concat.append(tempdf)
    data_for_autoencoder=concat(list_concat, axis =1)
    data_for_autoencoder.dropna(inplace = True)
    return data_for_autoencoder

#n_apis = 4
n_features = 34

#file open
malware_api_csv = "e103de89e5320990d334bde4e8def5b294163f2c46702286812d7ece8ffdef9a_3216.csv"
dataset = read_csv(malware_api_csv, header=None, index_col=None)
values = dataset.values
n_apis = values.shape[0] #timesteps as many as sample number(total row number in csv)
#reframed = values.reshape(1,values.shape[0]*values.shape[1])
print(values.shape)
df = DataFrame(values)

#scale to 0 1
values = values.astype('float32')
#reframed.to_csv("data_transformtoreconstruction_problem.csv")
scaler = MinMaxScaler(feature_range=(0, 1))
scaled = scaler.fit_transform(values)


# inorder to writeout
dfscaled = DataFrame(scaled)
print(dfscaled.shape)
dfscaled.to_csv("scaledto01.csv")


# reframe to 1 row case
reframed = scaled.reshape(1,values.shape[0]*values.shape[1])
train_X = reframed

# row split to apis inorder to specify the timestep input ex. [[API1,f1...f34],[API2, f1,f2, f34],....,[API,]]
train_X = train_X.reshape((train_X.shape[0], n_apis, n_features)) #if file format not change this line will has problem


print(train_X.shape[1],train_X.shape[2])
model = Sequential()
model.add(LSTM(34, input_shape=(train_X.shape[1], train_X.shape[2]), return_sequences=True)) # input_shape =(timesteps = n_apis, n_arguments)
#model.add(RepeatVector(n_apis))
model.add(LSTM(34, return_sequences=True))

model.compile(loss='mse', optimizer='adam') #momentum

history = model.fit(train_X, train_X, epochs=100, batch_size=1, shuffle=False)

model2 = Sequential()

model2.add(LSTM(34, input_shape=(train_X.shape[1], train_X.shape[2]), return_sequences=True, weights=model.layers[0].get_weights()))
activations = model2.predict(train_X)

print ("mmmmmmmmmmmmmmmmmmmmm")
#print (activations)
print (type(activations))
print (activations.shape)
print ("mmmmmmmmmmmmmmmmmmmmm")

pyplot.plot(history.history['loss'], label='train')
pyplot.legend()
pyplot.show()


yhat = model.predict(train_X)
print(yhat.shape)

yhat = yhat.reshape(n_apis , n_features)
print(yhat.shape)
yhat = scaler.inverse_transform(yhat)

df2 = DataFrame(yhat)
df2.to_csv("yhat_orig_value.csv")